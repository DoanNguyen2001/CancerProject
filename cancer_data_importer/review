#/confgi/__init__.py
from .db_config import DATABASE_CONFIG

__all__ = ['DATABASE_CONFIG']



#/confgi/db_config.py
import os
from dotenv import load_dotenv

load_dotenv()

DATABASE_CONFIG = {
    'dbname': os.getenv('Cancerdata'),
    'user': os.getenv('POSTGRES_USER'),
    'password': os.getenv('wnghks12!!'),
    'host': os.getenv('localhost'),
    'port': os.getenv('5432')
}

#/importers/__init__.py
from .base_importer import BaseImporter
from .av_patient_importer import AvPatientImporter

__all__ = ['BaseImporter', 'AvPatientImporter', 'AvTumourImporter']


#/av_gene_impoter.py
from .base_importer import BaseImporter
from datetime import datetime
import logging

#GENEID, Pseudonymised gene ID, Character, The format of this field in the Simulacrum is different from the format of GENEID
#TUMOURID, Pseudonymised tumour ID, Integer, The format of this field in the Simulacrum is deliberately different from the format of pseudonymised tumour id for real individuals
#PATIENTID, Pseudonymised patient ID, Integer, The format of this field in the Simulacrum is deliberately different from the format of pseudonymised patient id for real individuals
#GENE_DESC, Gene description, Character
#GENE, Gene code, Number, Number code of gene from genetictest.tsv (underlying table on genetic table in CAS)
#COUNT_TESTS, Count of genetic tests (dd) on this geneid, Number, The number of genetic tests on this gene based on unique genetic test id
#COUNT_RESULTS, Count of genetic test results (dd) on this geneid, Number
#COUNT_DATE, Number of test dates for this gene, Number, The number of test dates for each gene. (more that >1 test for a gene on same day counts as 1)
#ALL_TESTSTATUSES, Outcome of test is the test status. List of all test statuses ordered by date for this geneid, Character
#OVERALL_TS, Overall test status on whether anything abnormal on this gene, Character
#NO_OF_AB_GATS, Number of abnormal genetic aberration types, only counting definitive not borderline results, Number, Count of one for each of the below five genetic aberration types that are abnormal (max count = 5)
#DNASEQ_GAT, Overall test result for the genetic aberration type 'dna sequence', Character
#METHYL_GAT, Overall test result for the genetic aberration type 'methylation', Character
#EXP_GAT, Overall test result for the genetic aberration type 'expression', Character
#COPYNO_GAT, Overall test result for the genetic aberration type 'copyno', Character#
#FUS_TRANS_GAT, Overall test result for the genetic aberration type 'fusion/translocation', Character
#ABNORMAL_GAT, Type of genetic aberration if only one otherwise 'multiple', Character
#NO_OF_SEQ_VARS, Count of sequence variants for this gene, Number, Should only be populated if dnaseq_gat is not null
#ALL_SEQ_VARS, List of all sequence variants for this gene, Character, As above
#SEQ_VAR, Sequence variant for this gene if only one otherwise 'multiple', Character, As above
#DATE_OVERALL_TS, Test date for overall test status, Date, Based on best date for the worst/most conclusive i.e. overall test status
#BEST_DATE_SOURCE_OVERALL, Source of test (i.e molecular or pathology feed), Character, Based on the test with the best date and worst/most conclusive test status (i.e. test with DATE_OVERALL_TS)
#MIN_DATE, First test date for this gene, Date
#MAX_DATE, Last test date for this gene, Date, Many dates can be given for each genetic test. Each gene can have many best test dates. These variables give the earliest and la
#ALL_PRO_IMPS, List of all protein impacts for this gene, Character, Should only be populated if dnaseq_gat is not null
#NO_PRO_IMPS, Count of protein impacts for this gene, Integer, As above
#PRO_IMP, Protein impacts for this gene if only one otherwise 'multiple', Character, As above
#METHODS, The method of test, Character, For the overall test status
#LAB_NAME, Name of laboratory where test was performed, Character, Indicating if molecular or pathology lab; if molecular then name of molecular lab will be given

class AvGeneImporter(BaseImporter):
    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS AV_GENE (
            GENEID CHAR(30) primary key,
            TUMOURID INTEGER,
            PATIENTID INTEGER,
            GENE_DESC CHAR(30),
            GENE INTEGER,
            COUNT_TESTS INTEGER,
            COUNT_RESULTS INTEGER,
            COUNT_DATE INTEGER,
            ALL_TESTSTATUSES CHAR(300),
            OVERALL_TS char(150),
            NO_OF_AB_GATS INTEGER,
            DNASEQ_GAT char(150),
            METHYL_GAT char(150),
            EXP_GAT char(150),
            COPYNO_GAT char(150),
            FUS_TRANS_GAT char(150),
            ABNORMAL_GAT char(150),
            NO_OF_SEQ_VARS INTEGER,
            ALL_SEQ_VARS CHAR(150),
            SEQ_VAR CHAR(150),
            DATE_OVERALL_TS DATE,
            BEST_DATE_SOURCE_OVERALL_TS CHAR(150),
            MIN_DATE DATE,
            MAX_DATE DATE,
            ALL_PRO_IMPS CHAR(150),
            NO_PRO_IMPS INTEGER,
            PRO_IMP CHAR(150),
            METHODS CHAR(150),
            LAB_NAME CHAR(150)
                )''')

    def process_row(self, row):
        try:
            integer_fields = ['TUMOURID', 'PATIENTID', 'GENE', 'COUNT_TESTS', 'COUNT_RESULTS',
                              'COUNT_DATE', 'NO_OF_AB_GATS', 'NO_PRO_IMPS']
            for field in integer_fields:
                if row.get(field) == '':
                    row[field] = None
                elif row.get(field):
                    row[field] = int(row[field])

            date_fields = ['DATE_OVERALL_TS', 'MIN_DATE', 'MAX_DATE']

            for date_field in date_fields:
                if row.get(date_field) and row[date_field].strip():
                    try:
                        row[date_field] = datetime.strptime(row[date_field], '%Y-%m-%d').date()
                    except ValueError:
                        row[date_field] = None
                else:
                    row[date_field] = None

            sql = """INSERT INTO AV_GENE (GENEID, TUMOURID, PATIENTID, GENE_DESC, GENE,
                     COUNT_TESTS, COUNT_RESULTS, COUNT_DATE, ALL_TESTSTATUSES, OVERALL_TS,
                     NO_OF_AB_GATS, DNASEQ_GAT, METHYL_GAT, EXP_GAT, COPYNO_GAT,
                     FUS_TRANS_GAT, ABNORMAL_GAT, NO_OF_SEQ_VARS, ALL_SEQ_VARS, SEQ_VAR,
                     DATE_OVERALL_TS, BEST_DATE_SOURCE_OVERALL_TS, MIN_DATE, MAX_DATE,
                     ALL_PRO_IMPS, NO_PRO_IMPS, PRO_IMP, METHODS, LAB_NAME)
                     VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s,
                             %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)"""

            values = (
                row['GENEID'], row['TUMOURID'], row['PATIENTID'], row['GENE_DESC'],
                row['GENE'], row['COUNT_TESTS'], row['COUNT_RESULTS'], row['COUNT_DATE'],
                row['ALL_TESTSTATUSES'], row['OVERALL_TS'], row['NO_OF_AB_GATS'],
                row.get('DNASEQ_GAT'), row.get('METHYL_GAT'), row.get('EXP_GAT'),
                row.get('COPYNO_GAT'), row.get('FUS_TRANS_GAT'), row.get('ABNORMAL_GAT'),
                row['NO_OF_SEQ_VARS'], row.get('ALL_SEQ_VARS'), row.get('SEQ_VAR'),
                row['DATE_OVERALL_TS'], row.get('BEST_DATE_SOURCE_OVERALL_TS'),
                row['MIN_DATE'], row['MAX_DATE'], row.get('ALL_PRO_IMPS'),
                row.get('NO_PRO_IMPS'), row.get('PRO_IMP'), row.get('METHODS'),
                row.get('LAB_NAME')
            )
            return sql, values


        except KeyError as ke:
            print(f"Missing key in row: {ke}")
            return None

        except Exception as e:
            print(f"Unexpected error in processing row: {e}")
            return None


#/av_patient_importer.py
from .base_importer import BaseImporter
from datetime import datetime
import logging

    # PATIENTID, Pseudonymised patient ID, Int, The format of this field in the Simulacrum is deliberately different from the format of pseudonymised patient id for real individuals. For real individuals PATIENTID is different and stored in different formats.
    # GENDER,Person Stated gender, Char, Look up codes in ZGENDER
    # ZGENDER - 'CODE' - '1','2','9','X'
    # ETHNICITY, Ethnicity, Char, Look up codes in ZETHNICITY
    # ZETHICITY - 'CODE' - '0','8','A','B','C','C2','C3','CA','CB','CC','CD','CE','CF','CG','CH','CJ',
#                 'CK','CL','CM','CN','CP','CQ','CR','CS','CT','CU','CV','CW','CX','CY','D',
#                 'E','F','G','GA','GB','GC','GD','GE','GF','H','J','K','L','LA','LB','LC',
#                 'LD','LE','LF','LG','LH','LJ','LK','M','N','P','PA','PB','PC','PD','PE',
#                 'R','S','SA','SB','SC','SD','SE','X','Z'
    # DEATHCAUSECODE_1A, As provided with death notification, Char, Codes are in ICD-10 format, and may be a comma-separated list
    # DEATHCAUSECODE_1B, As provided with death notification, Char, Codes are in ICD-10 format, and may be a comma-separated list
    # DEATHCAUSECODE_1C, As provided with death notification, Char, Codes are in ICD-10 format, and may be a comma-separated list
    # DEATHCAUSECODE_2, As provided with death notification, Char, Codes are in ICD-10 format, and may be a comma-separated list
    # DEATHCAUSECODE_UNDERLYING, As provided with death notification, Char, Codes are in ICD-10 format, and may be a comma-separated list
    # DEATHLOCATIONCODE, Code of the location where the patient died, Char, Look up codes in ZDEATHLOCATION
    # ZDEATHLOCAITON - 'CODE' - '1','2','3','4','4077','4087','4097','4107','4117','4127','4137','5','X'
    # VITALSTATUS, vital status of the patient, Char, Look up codes in ZVITALSTATUS
    # ZVITALSTATUS - 'CODE' - 'A','A1','A2','A3','D','D1','D2','D3','D4','D5',
#                             'X1','X2','X3','X4','X5','X','I'
    # VITALSTATUSDATE, date of vital status, Date, If the patient has embarked or died, this is the corresponding date. If the patient is alive, this is the last date of follow-up.
    # LINKUMBER, substitute for HNS number in the real data(coded as NHSNUMBER), INT, The format and name of this field in the Simulacrum is deliberately different from the format of NHS numbers for real individuals.  For real individuals NHSNUMBER is different and stored in different formats.

class AvPatientImporter(BaseImporter):
    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS AV_PATIENT (
                PATIENTID INTEGER PRIMARY KEY NOT NULL,
                GENDER CHAR(1) NOT NULL,
                ETHNICITY CHAR(2),
                DEATHCAUSECODE_1A VARCHAR(20),
                DEATHCAUSECODE_1B VARCHAR(20),
                DEATHCAUSECODE_1C VARCHAR(20),
                DEATHCAUSECODE_2 VARCHAR(20),
                DEATHCAUSECODE_UNDERLYING VARCHAR(15),
                DEATHLOCATIONCODE CHAR(4),
                VITALSTATUS CHAR(2) NOT NULL,
                VITALSTATUSDATE DATE,
                LINKNUMBER INTEGER NOT NULL UNIQUE
            )
        ''')

    def process_row(self, row):
        try:
            required_fields = ['PATIENTID', 'GENDER', 'VITALSTATUS', 'LINKNUMBER']
            if not all(row.get(field) for field in required_fields):
                print(f"Missing required fields in row: {row}")
                return None

            if row.get('VITALSTATUSDATE'):
                try:
                    row['VITALSTATUSDATE'] = datetime.strptime(row['VITALSTATUSDATE'], '%Y-%m-%d').date()
                except ValueError as ve:
                    print(f"Date parsing error for row {row}: {ve}")
                    return None
            else: row['VITALSTATUSDATE'] = None

            sql = """INSERT INTO AV_PATIENT (PATIENTID, GENDER, ETHNICITY, DEATHCAUSECODE_1A, DEATHCAUSECODE_1B,
                      DEATHCAUSECODE_1C, DEATHCAUSECODE_2, DEATHCAUSECODE_UNDERLYING, DEATHLOCATIONCODE,
                      VITALSTATUS, VITALSTATUSDATE, LINKNUMBER)
                      VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)"""

            values = (
                row['PATIENTID'], row['GENDER'], row['ETHNICITY'],
                row.get('DEATHCAUSECODE_1A'), row.get('DEATHCAUSECODE_1B'),
                row.get('DEATHCAUSECODE_1C'), row.get('DEATHCAUSECODE_2'),
                row.get('DEATHCAUSECODE_UNDERLYING'), row.get('DEATHLOCATIONCODE'),
                row['VITALSTATUS'], row['VITALSTATUSDATE'], row['LINKNUMBER']
            )
            return sql, values

        except KeyError as ke:
            print(f"Missing key in row: {ke}")
            return None
        except Exception as e:
            print(f"Unexpected error in processing row: {e}")
            return None


#/av_tumour_impoter.py
from .base_importer import BaseImporter
from datetime import datetime
import logging

#TUMOURID, Pseudonymised tumour ID, Integer, The format of this field in the Simulacrum is deliberately different from the format of pseudonymised tumour id for real individuals. For real individuals TUMOURID is different and stored in different formats.
#GENDER, Person stated gender, Character, Consult ZGENDER for lookup table. Data is identical to that in AV_PATIENT and the field is present for convenience.
#PATIENTID, Pseudonymised patient ID, Integer, The format of this field in the Simulacrum is deliberately different from the format of pseudonymised patient id for real individuals. For real individuals PATIENTID is different and stored in different formats.
#DIAGNOSISDATEBEST, Diagnosis date, Date, Internal registration rules require that this be linked to pathological confirmation where possible, which means it is possible to observe treatment prior to recorded diagnosis.
#SITE_ICD10_O2_3CHAR, Site of neoplasm (3-character ICD-10/O2 code original version), Character, Consult ZICD for lookup table
#SITE_ICD10_O2, Site of neoplasm (4-character ICD-10/O2 code original version), Character, Consult ZICD for lookup table
#SITE_ICD10R4_O2_3CHAR_FROM2013, Site of neoplasm (3-character ICD-10/O2 code revision 2010) for diagnoses from 2013 onwards, Character, Look up codes at https://icd.who.int/browse10/2010/en#/II
#SITE_ICD10R4_O2_FROM2013, Site of neoplasm (4-character ICD-10/O2 code revision 2010) for diagnoses from 2013 onwards, Character, Look up codes at https://icd.who.int/browse10/2010/en#/II
#SITE_ICDO3REV2011, Site of neoplasm (3-character code ICD-O-3 1st revision 2013), Character, Look up codes at https://apps.who.int/iris/bitstream/handle/10665/96612/9789241548496_eng.pdf
#SITE_ICDO3REV2011_3CHAR, Site of neoplasm (4-character ICD-O-3 1st revision 2013), Character, Look up codes at https://apps.who.int/iris/bitstream/handle/10665/96612/9789241548496_eng.pdf
#MORPH_ICD10_O2, Histology of the cancer in the ICD-10/O2 system, Character, Consult ZHISTOLOGYLOOKUP for the lookup table for morphologies
#MORPH_ICDO3REV2011, Histology of the cancer in the ICD-O-3 1st revision 2013, Character, Look up codes at https://apps.who.int/iris/bitstream/handle/10665/96612/9789241548496_eng.pdf
#BEHAVIOUR_ICD10_O2, Behaviour of the cancer in the ICD-10/O2 system, Character, Consult ZBEHAVIOUR for lookup table
#BEHAVIOUR_ICDO3REV2011, Behaviour of the cancer in the ICD-O-3 1st revision 2013, Character, Look up codes at https://apps.who.int/iris/bitstream/handle/10665/96612/9789241548496_eng.pdf
#T_BEST, T stage flagged by the registry as the 'best' T stage, Character
#N_BEST, N stage flagged by the registry as the 'best' N stage, Character
#M_BEST, M stage flagged by the registry as the 'best' M stage, Character
#STAGE_BEST, Best 'registry' stage at diagnosis of the tumour, Character, Consult ZSTAGE for lookup table
#GRADE, Grade of tumour, Character, Consult ZGRADE for lookup table
#AGE, Age at diagnosis, Integer, Age is recorded in years
#CREG_CODE, Cancer registry catchment area code the patient was resident in when the tumour was diagnosed, Character, The CREG_CODE variable has been obfuscated so that its values do not correspond to real CREG code values
#STAGE_BEST_SYSTEM, System used to record best registry stage at diagnosis, Character
#LATERALITY, Laterality, Character, Consult ZLATERALITY for lookup table
#SCREENINGSTATUSFULL_CODE, Full detailed screening status of the tumour, Character, These are only available for certain primary sites
#ER_STATUS, Oestrogen receptor status of the tumour, Character, These are only available for certain primary sites
#PR_STATUS, Progesterone receptor status of the tumour, Character, These are only available for certain primary sites
#HER2_STATUS, HER2 status of the tumour, Character, These are only available for certain primary sites
#QUINTILE_2019, Measure of deprivation: the population-weighted quintile of income-level deprivation at small area level (LSAO), Character
#DATE_FIRST_SURGERY, Date of first surgical event linked to this tumour recorded in the Cancer Registration treatment table, Date, This is a derived field from the Cancer Registration treatment table
#CANCERCAREPLANINTENT, Intent of treatment as recorded in COSD Cancer Care Plan, Character, Consult ZCANCERCAREPLANINTENT for the lookup table
#PERFORMANCESTATUS, Performance status recorded at diagnosis, Character
#CHRL_TOT_27_03, Total Charlson comorbididy score, Integer, A combination of HES-derived and Registry-derived Charlson scores
#COMORBIDITIES_27_03, Charlson groups making up the total Charlson score for a lookback of 27 to 3 months, Character, Consult ZCOMORBIDITIES to look up the different Charlson comorbidity groups and their respective Charlson scores
#GLEASON_PRIMARY, Gleason primary pattern, Character, These are only available for certain primary sites
#GLEASON_SECONDARY, Gleason secondary pattern, Character, These are only available for certain primary sites
#GLEASON_TERTIARY, Gleason tertiary pattern, Character, These are only available for certain primary sites
#GLEASON_COMBINED, Combined Gleason primary and secondary scores, Integer, These are only available for certain primary sites

class AvTumourImporter(BaseImporter):
    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS AV_TUMOUR (
            TUMOURID INTEGER PRIMARY KEY,
            GENDER CHAR(30),
            PATIENTID INTEGER,
            DIAGNOSISDATEBEST DATE,
            SITE_ICD10_O2_3CHAR CHAR(3),
            SITE_ICD10_O2 CHAR(30),
            SITE_ICD10R4_O2_3CHAR_FROM2013 CHAR(3),
            SITE_ICD10R4_O2_FROM2013 CHAR(30),
            SITE_ICDO3REV2011 CHAR(30),
            SITE_ICDO3REV2011_3CHAR CHAR(3),
            MORPH_ICD10_O2 CHAR(30),
            MORPH_ICDO3REV2011 CHAR(30),
            BEHAVIOUR_ICD10_O2 CHAR(30),
            BEHAVIOUR_ICDO3REV2011 CHAR(30),
            T_BEST CHAR(30),
            N_BEST CHAR(30),
            M_BEST CHAR(30),
            STAGE_BEST CHAR(30),
            GRADE CHAR(30),
            AGE INTEGER,
            CREG_CODE CHAR(30),
            STAGE_BEST_SYSTEM CHAR(30),
            LATERALITY CHAR(30),
            SCREENINGSTATUSFULL_CODE CHAR(30),
            ER_STATUS CHAR(30),
            PR_STATUS CHAR(30),
            HER2_STATUS CHAR(30),
            QUINTILE_2019 CHAR(30),
            DATE_FIRST_SURGERY DATE,
            CANCERCAREPLANINTENT CHAR(30),
            PERFORMANCESTATUS CHAR(30),
            CHRL_TOT_27_03 CHAR(30),
            COMORBIDITIES_27_03 CHAR(60),
            GLEASON_PRIMARY CHAR(30),
            GLEASON_SECONDARY CHAR(30),
            GLEASON_TERTIARY CHAR(30),
            GLEASON_COMBINED INTEGER
                )''')

    def process_row(self, row):
        try:
            integer_fields = ['TUMOURID', 'PATIENTID', 'AGE', 'GLEASON_COMBINED']
            for field in integer_fields:
                if row.get(field) == '':
                    row[field] = None
                elif row.get(field):
                    row[field] = int(row[field])

            if row.get('DIAGNOSISDATEBEST'):
             try:
                row['DIAGNOSISDATEBEST'] = datetime.strptime(row['DIAGNOSISDATEBEST'], '%Y-%m-%d').date()
             except ValueError as ve:
                print(f"Date parsing error for DIAGNOSISDATEBEST: {ve}")
                return None

            if row.get('DATE_FIRST_SURGERY') and row['DATE_FIRST_SURGERY'].strip():
                try:
                    row['DATE_FIRST_SURGERY'] = datetime.strptime(row['DATE_FIRST_SURGERY'], '%Y-%m-%d').date()
                except ValueError:
                    row['DATE_FIRST_SURGERY'] = None
            else:
                row['DATE_FIRST_SURGERY'] = None


            sql = """INSERT INTO AV_TUMOUR (TUMOURID, GENDER, PATIENTID, DIAGNOSISDATEBEST,
                             SITE_ICD10_O2_3CHAR, SITE_ICD10_O2, SITE_ICD10R4_O2_3CHAR_FROM2013,
                             SITE_ICD10R4_O2_FROM2013, SITE_ICDO3REV2011, SITE_ICDO3REV2011_3CHAR,
                             MORPH_ICD10_O2, MORPH_ICDO3REV2011, BEHAVIOUR_ICD10_O2, BEHAVIOUR_ICDO3REV2011,
                             T_BEST, N_BEST, M_BEST, STAGE_BEST, GRADE, AGE, CREG_CODE, STAGE_BEST_SYSTEM,
                             LATERALITY, SCREENINGSTATUSFULL_CODE, ER_STATUS, PR_STATUS, HER2_STATUS,
                             QUINTILE_2019, DATE_FIRST_SURGERY, CANCERCAREPLANINTENT, PERFORMANCESTATUS,
                             CHRL_TOT_27_03, COMORBIDITIES_27_03, GLEASON_PRIMARY, GLEASON_SECONDARY,
                             GLEASON_TERTIARY, GLEASON_COMBINED)
                             VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s,
                                     %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s,
                                     %s, %s, %s)"""

            values = (
                row['TUMOURID'], row['GENDER'], row['PATIENTID'], row['DIAGNOSISDATEBEST'],
                row['SITE_ICD10_O2_3CHAR'], row['SITE_ICD10_O2'], row['SITE_ICD10R4_O2_3CHAR_FROM2013'],
                row['SITE_ICD10R4_O2_FROM2013'], row['SITE_ICDO3REV2011'], row['SITE_ICDO3REV2011_3CHAR'],
                row['MORPH_ICD10_O2'], row['MORPH_ICDO3REV2011'], row['BEHAVIOUR_ICD10_O2'],
                row['BEHAVIOUR_ICDO3REV2011'], row.get('T_BEST'), row.get('N_BEST'), row.get('M_BEST'),
                row['STAGE_BEST'], row['GRADE'], row['AGE'], row['CREG_CODE'], row.get('STAGE_BEST_SYSTEM'),
                row['LATERALITY'], row.get('SCREENINGSTATUSFULL_CODE'), row.get('ER_STATUS'),
                row.get('PR_STATUS'), row.get('HER2_STATUS'), row['QUINTILE_2019'],
                row.get('DATE_FIRST_SURGERY'), row.get('CANCERCAREPLANINTENT'),
                row.get('PERFORMANCESTATUS'), row['CHRL_TOT_27_03'], row.get('COMORBIDITIES_27_03'),
                row.get('GLEASON_PRIMARY'), row.get('GLEASON_SECONDARY'), row.get('GLEASON_TERTIARY'),
                row.get('GLEASON_COMBINED')
            )
            return sql, values

        except KeyError as ke:
            print(f"Missing key in row: {ke}")
            return None

        except Exception as e:
            print(f"Unexpected error in processing row: {e}")
            return None



#/base_importer.py

import psycopg2
from datetime import datetime
import csv
from abc import ABC, abstractmethod

class BaseImporter(ABC):
    def __init__(self, config):
        self.config = config
        self.conn = None
        self.cursor = None

    def connect(self):
        self.conn = psycopg2.connect(**self.config)
        self.cursor = self.conn.cursor()
        self.conn.autocommit = True

    def disconnect(self):
        if self.cursor:
            self.cursor.close()
        if self.conn:
            self.conn.close()

    @abstractmethod
    def create_table(self):
        pass

    @abstractmethod
    def process_row(self, row):
        pass

    def import_rows(self, file_path):
        total_rows = 0
        successful_imports = 0

        try:
            self.connect()
            self.create_table()

            with open(file_path, 'r') as csv_file:
                csv_reader = csv.DictReader(csv_file)
                for row in csv_reader:
                    total_rows += 1
                    try:
                        processed_row = self.process_row(row)
                        if processed_row:
                            self.cursor.execute(processed_row[0], processed_row[1])
                            successful_imports += 1

                            if successful_imports % 1000 == 0:
                                print(f"Processed {successful_imports} rows")

                    except Exception as e:
                        print(f"Error on row {total_rows}: {e}")
                        continue

            print(f"\nImport completed: {successful_imports} rows")
            print(f"Total rows: {total_rows}")
            print(f"Successful: {successful_imports}")
            print(f"Failed: {total_rows - successful_imports}")

        finally:
            self.disconnect()


#./__init__.py

from .config.db_config import DATABASE_CONFIG
from .importers.base_importer import BaseImporter
from .importers.av_patient_importer import AVpatientImporter

__all__ = ['DATABASE_CONFIG', 'BaseImporter', 'AVpatientImporter']

#./main.py
import os
import importlib
import sys
from config.db_config import DATABASE_CONFIG

print(sys.path, "\n")


def get_available_importers():
    importers = {}
    counter = 1
    importers_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "importers")

    for file in os.listdir(importers_dir):
        if file.endswith('_importer.py') and file != 'base_importer.py':
            module_name = file[:-3]
            class_name = ''.join(word.capitalize() for word in module_name.split('_')[:-1]) + 'Importer'

            print(f"Detected module: {module_name}, \n"
                  f"class: {class_name},\n")
            importers[counter] = (module_name, class_name)
            counter += 1
    return importers


def main():

    importers = get_available_importers()

    print("Available importers: ")
    for num, (module, class_name) in importers.items():
        print(f"{num}: {module}")


    try:
        choice = int(input("\nChoose an importer number: "))
        if choice not in importers:
            raise ValueError("Invalid importer number")

        module_name, class_name = importers[choice]
        module = importlib.import_module(f"importers.{module_name}")
        importer_class = getattr(module, class_name)

        file_path = input("Enter CSV file path: ")
        if not os.path.isfile(file_path):
            raise FileNotFoundError("File not found")

        importer = importer_class(DATABASE_CONFIG)
        importer.import_rows(file_path)

    except ValueError as ve:
        print(f"Invalid input: {ve}")

    except FileNotFoundError as fnf:
        print(f"File error: {fnf}")

    except AttributeError as ae:
        print(f"Importer class not found: {ae}")

    except Exception as e:
        print(f"Unexpected error: {e}")

if __name__ == "__main__":
    main()
